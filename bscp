#!/usr/bin/env python

# Copyright (C) 2012-2016
#
# * Volker Diels-Grabsch <v@njh.eu>
# * art0int <zvn_mail@mail.ru>
# * Matthew Fearnley (matthew.w.fearnley@gmail.com)
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

from __future__ import print_function
import hashlib
import struct
import subprocess
import sys
import os
import lz4.frame

remote_script = r'''
import hashlib
import os
import os.path
import struct
import sys
import threading
import lz4.frame

(size, blocksize, filename_len, hashname_len) = struct.unpack('<QQQQ', sys.stdin.read(8+8+8+8))
filename = sys.stdin.read(filename_len)
hashname = sys.stdin.read(hashname_len)
hashfilename = filename + '.' + hashname

def writeThread():
    h = open(hashfilename, 'rb+')
    h.seek(0, 2)
    h.seek(0)
    f = open(filename, 'rb+')
    f.seek(0, 2)
    f.seek(0)

    while True:
        confirm = sys.stdin.read(6)
        if confirm == 'update':
            (position, size) = struct.unpack('<QQ', sys.stdin.read(8+8))
            block = lz4.frame.decompress(sys.stdin.read(size))
            #block = sys.stdin.read(size)
            digest = hashlib.new(hashname, block).digest()
            f.seek(position)
            f.write(block)
            h.seek(position / blocksize * hashsize)
            h.write(digest)
        else:
            break

    return

sanity_hash = hashlib.new(hashname, filename).digest()
sys.stdout.write(sanity_hash)
sys.stdout.flush()
cmd = sys.stdin.read(2)
if cmd != 'go' and cmd != 'ho':
    sys.exit()

if not os.path.exists(filename):
    # Create sparse file
    with open(filename, 'wb') as f:
        f.truncate(size)
    os.chmod(filename, 0600)

hashsize = hashlib.new(hashname).digestsize

if not os.path.exists(hashfilename):
    with open(hashfilename, 'wb') as h:
        h.truncate(0)
    os.chmod(hashfilename, 0600)

h = open(hashfilename, 'rb+')
h.seek(0, 2)
h.seek(0)

with open(filename, 'rb+') as f:
    thread = threading.Thread(target=writeThread)
    thread.daemon = True
    thread.start()

    f.seek(0, 2)
    sys.stdout.write(struct.pack('<Q', f.tell()))
    sys.stdout.flush()
    readremain = size
    rblocksize = blocksize
    f.seek(0)
    position = 0
    while True:
        if readremain <= blocksize:
            rblocksize = readremain
        digest = h.read(hashsize)
        if len(digest) != hashsize:
            f.seek(position)
            block = f.read(rblocksize)
            if len(block) < rblocksize:
                break
            digest = hashlib.new(hashname, block).digest()
            h.seek(position / blocksize * hashsize)
            h.write(digest)
            h.flush()
        sys.stdout.write(digest)
        sys.stdout.flush()
        position += rblocksize
        readremain -= rblocksize
        if readremain == 0:
            break

    thread.join()
'''

class IOCounter:
    def __init__(self, in_stream, out_stream):
        self.in_stream = in_stream
        self.out_stream = out_stream
        self.in_total = 0
        self.out_total = 0
    def read(self, size=None):
        if size is None:
            s = self.in_stream.read()
        else:
            s = self.in_stream.read(size)
        self.in_total += len(s)
        return s
    def write(self, s):
        self.out_stream.write(s)
        self.out_total += len(s)
        self.out_stream.flush()

def bscp(local_filename, remote_host, remote_filename, blocksize, hashname):
    hash_total = hashlib.new(hashname)
    with open(local_filename, 'rb') as f:
        f.seek(0, 2)
        size = f.tell()
        f.seek(0)

        if blocksize == 0:
            blocksize = size / 10240
            if blocksize < 64 * 1024:
                blocksize = 64 * 1024

        # Calculate number of blocks, including the last block which may be smaller
        blockcount = int((size + blocksize - 1) / blocksize)

        print('blocks %i x %i' % (blockcount, blocksize))

        remote_command = 'python2.7 -c "%s"' % (remote_script,)
        command = ('ssh', '--', remote_host, remote_command)
        p = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        io = IOCounter(p.stdout, p.stdin)

        io.write(struct.pack('<QQQQ', size, blocksize, len(remote_filename), len(hashname)))
        io.write(remote_filename)
        io.write(hashname)

        sanity_digest = hashlib.new(hashname, remote_filename).digest()
        remote_digest = io.read(len(sanity_digest))
        if remote_digest != sanity_digest:
            print(remote_digest + io.read(100))
            print(sanity_digest)
            raise RuntimeError('Remote script failed to execute properly')
        io.write('go')

        (remote_size,) = struct.unpack('<Q', io.read(8))
        if remote_size < size:
            raise RuntimeError('Remote size less than local (local: %i, remote: %i)' % (size, remote_size))

        changed_blocks = 0
        skipped_blocks = 0

        for i in xrange(blockcount):
            position = f.tell()
            print('%i / %i = %i%% total (%i%% changed, blocks skipped %i, blocks changed %i) READ' % (position, size, (position) * 100 / size, changed_blocks * 100 / blockcount, skipped_blocks, changed_blocks), end = '\r')
            sys.stdout.flush()
            block = f.read(blocksize)
            hash_total.update(block)
            digest = hashlib.new(hashname, block).digest()
            print('%i / %i = %i%% total (%i%% changed, blocks skipped %i, blocks changed %i) WAIT' % (position + len(block), size, (position + len(block)) * 100 / size, changed_blocks * 100 / blockcount, skipped_blocks, changed_blocks), end = '\r')
            sys.stdout.flush()
            remote_digest = io.read(hash_total.digestsize)
            if digest != remote_digest:
                io.write('update')
                compressed_block = lz4.frame.compress(block)
                #compressed_block = block;
                changed_blocks += 1
                print('%i / %i = %i%% total (%i%% changed, blocks skipped %i, blocks changed %i) SEND' % (position + len(block), size, (position + len(block)) * 100 / size, changed_blocks * 100 / blockcount, skipped_blocks, changed_blocks), end = '\r')
                sys.stdout.flush()
                io.write(struct.pack('<QQ', position, len(compressed_block)))
                io.write(compressed_block)
            else:
                skipped_blocks += 1

        io.write('doneho')
        print()

        p.stdin.close()

    return (io.in_total, io.out_total, size)

if __name__ == '__main__':
    try:
        local_filename = sys.argv[1]
        (remote_host, remote_filename) = sys.argv[2].split(':')
        if len(sys.argv) >= 4:
            blocksize = int(sys.argv[3])
        else:
            blocksize = 0
        if len(sys.argv) >= 5:
            hashname = sys.argv[4]
        else:
            hashname = 'sha1'
        assert len(sys.argv) <= 5
    except:
        usage = 'bscp SRC HOST:DEST [BLOCKSIZE] [HASH]'
        sys.stderr.write('Usage:\n\n    %s\n\n' % (usage,))
        sys.exit(1)
    (in_total, out_total, size) = bscp(local_filename, remote_host, remote_filename, blocksize, hashname)
    speedup = size * 1.0 / (in_total + out_total)
    sys.stderr.write('in=%i out=%i size=%i speedup=%.2f\n' % (in_total, out_total, size, speedup))
